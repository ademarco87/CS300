# CS300
SNHU CS-300 Analysis and Design

**What was the problem you were solving in the projects for this course?**
    Each module in this course had different challenges. These challenges were to complete code that was provided for a Linked List, hash & Binary tree; Following the three data types, a run-time analysis was conducted to understand the memory management of each type. The course then culminated into a final project that was to take a provided .csv file that contained course numbers, names and their prerequisits and create code that could manage the data provided in it. Based on my run time analysis, and ultimately not knowing the length of the provided file upfront, I chose to mange the file with a hash table.


**How did you approach the problem?**
    In the culminating project, I understood the value of memory management between the different data sets. Looking back, I was unaware of the length the .csv file would provide (albiet it was short). With an unknown length, and the knowledge of run-time and memory management, I chose the hash table as it would handle file reading and validation, extracting the course numbers, titles and their prerequisits for proper formatting and handling of errors. While the other methods could have been used, the hash table seemed to be the most appropriate as it can ultimately expand as needed while still maintaining proper memory management and runtime. As such, the .csv file can be expanded for a great length of information and the table can still manage without much change. In context, the code has a menu-driven interface to allow the user to load the data, display a sorted list of course data and retrieve more detailed information by entering a specific course number, which then displays the particular course and prerequisits (or displaying "none") as appropriate. The data structure stores course data in an variable called `unordered_map` and correspindg `Course` object containing the course title and prerequisit as a vector of strings. The code was designed to be modular and scalable.


**How did you overcome any roadblocks you encountered while going through the activities or project?**
    In the final project, first challenge was that no code was provided and direction of that no .CSV parser would be provided, that all code should be a single file. To overcome this, the .csv file would need to be loaded and formated from the single .cpp file. The logic function iterated each line, extracted the details using stringstream, and handled edge cases such as white space and used course number validation to ensure data consistency. The function included error handling if one should arise.
    As such, the handling of prerequisite needed varification. To overcome this, I utilized `allCourses` to track and validate course numbers from the file. It was then cross checked against the rerequisites to ensure it exsisted. It was a proactive approach to minimize runtime errors and maintained the readability.
    Aside form the logic of the program, a user-friendly interface was made using case logic, where the user can select a menu-driven number for interaction. The `displayMenu` clearly defined and preseneted to the user to select from. It also included error handling and validates the inputs from the user before executing.
    Lastly, due to potentially handling a large dataset, the hash table was used, as mentioned above in my approach. It was selected to maximized efficiency and responsiveness. As stated previous, the datatype was chosen with scalability and responsivness in mind, allowing the user to interact with the program with efficiency in the data processing. 


**How has your work on this project expanded your approach to designing software and developing programs?**
    The challenge underscored the importance of runtime and memory management. Using robust data structures and how to implement them to manage data effiently was the cornerstone of this course. Optimizing runtime performance and ensuring effective management in more complex algorithms. Learning the balance between complex algorithms and resource management was integral to developing software that meets performance and scalability requirements. In short, choosing the right tools and techniques to manage data effectively.


**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**
    I've learned the importance of balancing code and complexity. On my journy thus far, One of my projects in the 100 course levels, the project was 800+ lines of code on completion. Now, I could probably shorten that project with better handling with more robust algorithms and error handling, which would improve the overall readablity and error handling (it contained repeated code to handle input validations, under different variables). Utilizing more modular code designs with clear documentation would enhance code clarity and reliability. By implementing robust algorithms and handling techniques, I would not only streamline the project but also improve readability and error handling significantly. This approach would eliminate repeated code segments dedicated to input validations across different variables, consolidating functionality into reusable modules. The journey through various projects has underscored the importance of maintaining a balanced codebase—optimized for efficiency, maintainability, and scalability—while adhering to best practices and standards. These insights have shaped my approach to programming, emphasizing the continual pursuit of improving code quality and enhancing the overall software development process. Thus, while this code seems more complex, it is significantly less lines of code and provides data management with error handling. 
    
